// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: llbuild3/Engine.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// This source file is part of the Swift.org open source project
//
// Copyright (c) 2024-2025 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

//// Signature represents the version of an object and is used in all cache keys
//// computed for that object. Signature does not require the encoding of any
//// particular hash function. Instead, it is expected that the provider chooses
//// a function that guarantees cache consistency.
public struct Llbuild3_Signature: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bytes: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// This object contains the result of executing a task
public struct Llbuild3_TaskResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var artifacts: [Llbuild3_Artifact] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Llbuild3_TaskInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var inputObject: Llbuild3_TaskInput.OneOf_InputObject? = nil

  public var error: Llbuild3_Error {
    get {
      if case .error(let v)? = inputObject {return v}
      return Llbuild3_Error()
    }
    set {inputObject = .error(newValue)}
  }

  public var artifact: Llbuild3_Artifact {
    get {
      if case .artifact(let v)? = inputObject {return v}
      return Llbuild3_Artifact()
    }
    set {inputObject = .artifact(newValue)}
  }

  public var result: Llbuild3_TaskResult {
    get {
      if case .result(let v)? = inputObject {return v}
      return Llbuild3_TaskResult()
    }
    set {inputObject = .result(newValue)}
  }

  public var action: Llbuild3_ActionResult {
    get {
      if case .action(let v)? = inputObject {return v}
      return Llbuild3_ActionResult()
    }
    set {inputObject = .action(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_InputObject: Equatable, Sendable {
    case error(Llbuild3_Error)
    case artifact(Llbuild3_Artifact)
    case result(Llbuild3_TaskResult)
    case action(Llbuild3_ActionResult)

  }

  public init() {}
}

public struct Llbuild3_TaskInputs: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var inputs: [Llbuild3_TaskInput] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Llbuild3_TaskContext: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskState: Llbuild3_TaskContext.OneOf_TaskState? = nil

  public var casState: Llbuild3_CASObjectID {
    get {
      if case .casState(let v)? = taskState {return v}
      return Llbuild3_CASObjectID()
    }
    set {taskState = .casState(newValue)}
  }

  public var protoState: SwiftProtobuf.Google_Protobuf_Any {
    get {
      if case .protoState(let v)? = taskState {return v}
      return SwiftProtobuf.Google_Protobuf_Any()
    }
    set {taskState = .protoState(newValue)}
  }

  public var intState: Int64 {
    get {
      if case .intState(let v)? = taskState {return v}
      return 0
    }
    set {taskState = .intState(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_TaskState: Equatable, Sendable {
    case casState(Llbuild3_CASObjectID)
    case protoState(SwiftProtobuf.Google_Protobuf_Any)
    case intState(Int64)

  }

  public init() {}
}

public struct Llbuild3_TaskWait: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ids: [UInt64] = []

  public var context: Llbuild3_TaskContext {
    get {return _context ?? Llbuild3_TaskContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Llbuild3_TaskContext? = nil
}

public struct Llbuild3_TaskNextState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var stateValue: Llbuild3_TaskNextState.OneOf_StateValue? = nil

  public var wait: Llbuild3_TaskWait {
    get {
      if case .wait(let v)? = stateValue {return v}
      return Llbuild3_TaskWait()
    }
    set {stateValue = .wait(newValue)}
  }

  public var result: Llbuild3_TaskResult {
    get {
      if case .result(let v)? = stateValue {return v}
      return Llbuild3_TaskResult()
    }
    set {stateValue = .result(newValue)}
  }

  public var error: Llbuild3_Error {
    get {
      if case .error(let v)? = stateValue {return v}
      return Llbuild3_Error()
    }
    set {stateValue = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_StateValue: Equatable, Sendable {
    case wait(Llbuild3_TaskWait)
    case result(Llbuild3_TaskResult)
    case error(Llbuild3_Error)

  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "llbuild3"

extension Llbuild3_Signature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Signature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.bytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.bytes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Llbuild3_Signature, rhs: Llbuild3_Signature) -> Bool {
    if lhs.bytes != rhs.bytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Llbuild3_TaskResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "artifacts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.artifacts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.artifacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.artifacts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Llbuild3_TaskResult, rhs: Llbuild3_TaskResult) -> Bool {
    if lhs.artifacts != rhs.artifacts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Llbuild3_TaskInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "error"),
    3: .same(proto: "artifact"),
    4: .same(proto: "result"),
    5: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try {
        var v: Llbuild3_Error?
        var hadOneofValue = false
        if let current = self.inputObject {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.inputObject = .error(v)
        }
      }()
      case 3: try {
        var v: Llbuild3_Artifact?
        var hadOneofValue = false
        if let current = self.inputObject {
          hadOneofValue = true
          if case .artifact(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.inputObject = .artifact(v)
        }
      }()
      case 4: try {
        var v: Llbuild3_TaskResult?
        var hadOneofValue = false
        if let current = self.inputObject {
          hadOneofValue = true
          if case .result(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.inputObject = .result(v)
        }
      }()
      case 5: try {
        var v: Llbuild3_ActionResult?
        var hadOneofValue = false
        if let current = self.inputObject {
          hadOneofValue = true
          if case .action(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.inputObject = .action(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    switch self.inputObject {
    case .error?: try {
      guard case .error(let v)? = self.inputObject else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .artifact?: try {
      guard case .artifact(let v)? = self.inputObject else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .result?: try {
      guard case .result(let v)? = self.inputObject else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .action?: try {
      guard case .action(let v)? = self.inputObject else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Llbuild3_TaskInput, rhs: Llbuild3_TaskInput) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.inputObject != rhs.inputObject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Llbuild3_TaskInputs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskInputs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Llbuild3_TaskInputs, rhs: Llbuild3_TaskInputs) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Llbuild3_TaskContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "casState"),
    2: .same(proto: "protoState"),
    3: .same(proto: "intState"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Llbuild3_CASObjectID?
        var hadOneofValue = false
        if let current = self.taskState {
          hadOneofValue = true
          if case .casState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.taskState = .casState(v)
        }
      }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Any?
        var hadOneofValue = false
        if let current = self.taskState {
          hadOneofValue = true
          if case .protoState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.taskState = .protoState(v)
        }
      }()
      case 3: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.taskState != nil {try decoder.handleConflictingOneOf()}
          self.taskState = .intState(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.taskState {
    case .casState?: try {
      guard case .casState(let v)? = self.taskState else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .protoState?: try {
      guard case .protoState(let v)? = self.taskState else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .intState?: try {
      guard case .intState(let v)? = self.taskState else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Llbuild3_TaskContext, rhs: Llbuild3_TaskContext) -> Bool {
    if lhs.taskState != rhs.taskState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Llbuild3_TaskWait: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskWait"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .same(proto: "context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.ids) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.ids.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.ids, fieldNumber: 1)
    }
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Llbuild3_TaskWait, rhs: Llbuild3_TaskWait) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs._context != rhs._context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Llbuild3_TaskNextState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskNextState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "wait"),
    2: .same(proto: "result"),
    3: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Llbuild3_TaskWait?
        var hadOneofValue = false
        if let current = self.stateValue {
          hadOneofValue = true
          if case .wait(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stateValue = .wait(v)
        }
      }()
      case 2: try {
        var v: Llbuild3_TaskResult?
        var hadOneofValue = false
        if let current = self.stateValue {
          hadOneofValue = true
          if case .result(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stateValue = .result(v)
        }
      }()
      case 3: try {
        var v: Llbuild3_Error?
        var hadOneofValue = false
        if let current = self.stateValue {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stateValue = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.stateValue {
    case .wait?: try {
      guard case .wait(let v)? = self.stateValue else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .result?: try {
      guard case .result(let v)? = self.stateValue else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.stateValue else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Llbuild3_TaskNextState, rhs: Llbuild3_TaskNextState) -> Bool {
    if lhs.stateValue != rhs.stateValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
